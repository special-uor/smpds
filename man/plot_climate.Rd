% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils-plot.R
\name{plot_climate}
\alias{plot_climate}
\alias{plot_climate_countour}
\alias{plot_climate_tiles}
\alias{plot_gdd}
\alias{plot_mat}
\alias{plot_mi}
\alias{plot_mtco}
\alias{plot_mtwa}
\title{Plot climate variable}
\usage{
plot_climate(
  .data,
  var = "mat",
  units = NA,
  fill_scale = ggplot2::scale_fill_viridis_d(name = toupper(var)),
  size = 1,
  stroke = 0.1,
  legend.key.width = ggplot2::unit(1, "cm"),
  legend.position = "bottom",
  xlim = c(-180, 180),
  ylim = c(-60, 90),
  show_plot = TRUE,
  elevation_cut = NULL,
  land_borders = rnaturalearth::ne_countries(scale = "small", returnclass = "sf"),
  land_borders_colour = "black",
  land_borders_size = 0.25,
  fill_land = "white",
  fill_sea = "#CFE2F3",
  contour = FALSE,
  ...
)

plot_climate_countour(
  .data,
  var = "mat",
  units = NA,
  fill_scale = ggplot2::scale_fill_gradientn(name = toupper(var), colours =
    wesanderson::wes_palette("Zissou1", 100, type = "continuous")),
  size = 1,
  stroke = 0.5,
  legend.key.width = ggplot2::unit(2, "cm"),
  legend.position = "bottom",
  xlim = c(-180, 180),
  ylim = c(-60, 90),
  show_plot = TRUE,
  elevation_cut = NULL,
  land_borders = rnaturalearth::ne_countries(scale = "small", returnclass = "sf"),
  land_borders_colour = "black",
  land_borders_size = 0.25,
  fill_land = "white",
  fill_sea = "#CFE2F3",
  ...
)

plot_climate_tiles(
  .data,
  var = "mat",
  units = NA,
  fill_scale = ggplot2::scale_fill_viridis_d(name = toupper(var)),
  size = 1,
  stroke = 0.1,
  legend.key.width = ggplot2::unit(1, "cm"),
  legend.position = "bottom",
  xlim = c(-180, 180),
  ylim = c(-60, 90),
  show_plot = TRUE,
  elevation_cut = NULL,
  land_borders = rnaturalearth::ne_countries(scale = "small", returnclass = "sf"),
  land_borders_colour = "black",
  land_borders_size = 0.25,
  fill_land = "white",
  fill_sea = "#CFE2F3",
  contour = FALSE,
  ...
)

plot_gdd(
  .data,
  baseline = 0,
  size = 1,
  stroke = 0.1,
  legend.key.width = ggplot2::unit(1, "cm"),
  legend.position = "bottom",
  xlim = c(-180, 180),
  ylim = c(-60, 90),
  show_plot = TRUE,
  ...
)

plot_mat(
  .data,
  size = 1,
  stroke = 0.1,
  legend.key.width = ggplot2::unit(1, "cm"),
  legend.position = "bottom",
  xlim = c(-180, 180),
  ylim = c(-60, 90),
  show_plot = TRUE,
  ...
)

plot_mi(
  .data,
  size = 1,
  stroke = 0.1,
  legend.key.width = ggplot2::unit(1, "cm"),
  legend.position = "bottom",
  xlim = c(-180, 180),
  ylim = c(-60, 90),
  show_plot = TRUE,
  ...
)

plot_mtco(
  .data,
  size = 1,
  stroke = 0.1,
  legend.key.width = ggplot2::unit(1, "cm"),
  legend.position = "bottom",
  xlim = c(-180, 180),
  ylim = c(-60, 90),
  show_plot = TRUE,
  ...
)

plot_mtwa(
  .data,
  size = 1,
  stroke = 0.1,
  legend.key.width = ggplot2::unit(1, "cm"),
  legend.position = "bottom",
  xlim = c(-180, 180),
  ylim = c(-60, 90),
  show_plot = TRUE,
  ...
)
}
\arguments{
\item{.data}{Data frame with spatial and climate data. The following are
expected:
\itemize{
\item \strong{Latitude}, named: \code{latitude}, \code{lat} or \code{y}.
\item \strong{Longitude}, named: \code{longitude}, \code{long}, \code{lon}
or \code{y}.
\item \strong{Main variable}, named: value of \code{var}.
}}

\item{var}{String with the name of the climate variable to plot. Default:
\code{"mat"} (Mean Annual Temperature).}

\item{units}{String with the units to display next to the legend tittle.
Default: \code{NA}.}

\item{fill_scale}{\code{ggplot2} compatible object with information on how to
fill the individual points for the climate variable. Default:
\code{ggplot2::scale_fill_viridis_c(name = toupper(var))}.}

\item{size}{Numeric value for the \code{size} aesthetic.}

\item{stroke}{Numeric value for the \code{stroke} aesthetic.}

\item{legend.key.width}{size of legend keys (\code{unit}); key background height & width inherit from
\code{legend.key.size} or can be specified separately}

\item{legend.position}{the position of legends ("none", "left", "right",
"bottom", "top", or two-element numeric vector)}

\item{xlim}{Limits for the x and y axes. These limits are specified
in the units of the default CRS. By default, this means projected coordinates
(\code{default_crs = NULL}). How limit specifications translate into the exact
region shown on the plot can be confusing when non-linear or rotated coordinate
systems are used as the default crs. First, different methods can be preferable
under different conditions. See parameter \code{lims_method} for details. Second,
specifying limits along only one direction can affect the automatically generated
limits along the other direction. Therefore, it is best to always specify limits
for both x and y. Third, specifying limits via position scales or \code{xlim()}/\code{ylim()}
is strongly discouraged, as it can result in data points being dropped from the plot even
though they would be visible in the final plot region.}

\item{ylim}{Limits for the x and y axes. These limits are specified
in the units of the default CRS. By default, this means projected coordinates
(\code{default_crs = NULL}). How limit specifications translate into the exact
region shown on the plot can be confusing when non-linear or rotated coordinate
systems are used as the default crs. First, different methods can be preferable
under different conditions. See parameter \code{lims_method} for details. Second,
specifying limits along only one direction can affect the automatically generated
limits along the other direction. Therefore, it is best to always specify limits
for both x and y. Third, specifying limits via position scales or \code{xlim()}/\code{ylim()}
is strongly discouraged, as it can result in data points being dropped from the plot even
though they would be visible in the final plot region.}

\item{show_plot}{Boolean flag to indicate whether or not the graphic should
be displayed, if \code{FALSE}, it only returns the \code{ggplot2} object.
Default: \code{TRUE}.}

\item{elevation_cut}{Numeric value to use as the threshold of the elevation
at which the sites will be represented with different shapes.}

\item{land_borders}{Data frame with polygons to represent land borders
(e.g. continents, countries, counties, etc.).
Default: \code{rnaturalearth::ne_countries}.}

\item{land_borders_colour}{String containing a colour code (HEX value) or
colour name, to be used as colour for the land borders.
Default: \code{"black"}.}

\item{land_borders_size}{Numeric value of the line size to draw the land
borders. Default: \code{0.25}}

\item{fill_land}{String containing a colour code (HEX value) or colour
name, to be used as filling for the countries.
Default: \code{NA} (transparent).}

\item{fill_sea}{String containing a colour code (HEX value) or colour
name, to be used as filling for the seas
Default: \code{NA} (transparent).}

\item{contour}{Boolean flag to indicate if a contour should be overlaid
on the individual sites/points. It uses the function \code{\link[akima:interp]{akima::interp()}}
to interpolate values from the nearest available points.}

\item{...}{
  Arguments passed on to \code{\link[ggplot2:ggsf]{ggplot2::coord_sf}}
  \describe{
    \item{\code{expand}}{If \code{TRUE}, the default, adds a small expansion factor to
the limits to ensure that data and axes don't overlap. If \code{FALSE},
limits are taken exactly from the data or \code{xlim}/\code{ylim}.}
    \item{\code{crs}}{The coordinate reference system (CRS) into which all data should
be projected before plotting. If not specified, will use the CRS defined
in the first sf layer of the plot.}
    \item{\code{default_crs}}{The default CRS to be used for non-sf layers (which
don't carry any CRS information) and scale limits. The default value of
\code{NULL} means that the setting for \code{crs} is used. This implies that all
non-sf layers and scale limits are assumed to be specified in projected
coordinates. A useful alternative setting is \code{default_crs = sf::st_crs(4326)},
which means x and y positions are interpreted as longitude and latitude,
respectively, in the World Geodetic System 1984 (WGS84).}
    \item{\code{datum}}{CRS that provides datum to use when generating graticules.}
    \item{\code{label_graticule}}{Character vector indicating which graticule lines should be labeled
where. Meridians run north-south, and the letters \code{"N"} and \code{"S"} indicate that
they should be labeled on their north or south end points, respectively.
Parallels run east-west, and the letters \code{"E"} and \code{"W"} indicate that they
should be labeled on their east or west end points, respectively. Thus,
\code{label_graticule = "SW"} would label meridians at their south end and parallels at
their west end, whereas \code{label_graticule = "EW"} would label parallels at both
ends and meridians not at all. Because meridians and parallels can in general
intersect with any side of the plot panel, for any choice of \code{label_graticule} labels
are not guaranteed to reside on only one particular side of the plot panel. Also,
\code{label_graticule} can cause labeling artifacts, in particular if a graticule line
coincides with the edge of the plot panel. In such circumstances, \code{label_axes} will
generally yield better results and should be used instead.

This parameter can be used alone or in combination with \code{label_axes}.}
    \item{\code{label_axes}}{Character vector or named list of character values
specifying which graticule lines (meridians or parallels) should be labeled on
which side of the plot. Meridians are indicated by \code{"E"} (for East) and
parallels by \code{"N"} (for North). Default is \code{"--EN"}, which specifies
(clockwise from the top) no labels on the top, none on the right, meridians
on the bottom, and parallels on the left. Alternatively, this setting could have been
specified with \code{list(bottom = "E", left = "N")}.

This parameter can be used alone or in combination with \code{label_graticule}.}
    \item{\code{lims_method}}{Method specifying how scale limits are converted into
limits on the plot region. Has no effect when \code{default_crs = NULL}.
For a very non-linear CRS (e.g., a perspective centered
around the North pole), the available methods yield widely differing results, and
you may want to try various options. Methods currently implemented include \code{"cross"}
(the default), \code{"box"}, \code{"orthogonal"}, and \code{"geometry_bbox"}. For method \code{"cross"},
limits along one direction (e.g., longitude) are applied at the midpoint of the
other direction (e.g., latitude). This method avoids excessively large limits for
rotated coordinate systems but means that sometimes limits need to be expanded a
little further if extreme data points are to be included in the final plot region.
By contrast, for method \code{"box"}, a box is generated out of the limits along both directions,
and then limits in projected coordinates are chosen such that the entire box is
visible. This method can yield plot regions that are too large. Finally, method
\code{"orthogonal"} applies limits separately along each axis, and method
\code{"geometry_bbox"} ignores all limit information except the bounding boxes of any
objects in the \code{geometry} aesthetic.}
    \item{\code{ndiscr}}{Number of segments to use for discretising graticule lines;
try increasing this number when graticules look incorrect.}
    \item{\code{default}}{Is this the default coordinate system? If \code{FALSE} (the default),
then replacing this coordinate system with another one creates a message alerting
the user that the coordinate system is being replaced. If \code{TRUE}, that warning
is suppressed.}
    \item{\code{clip}}{Should drawing be clipped to the extent of the plot panel? A
setting of \code{"on"} (the default) means yes, and a setting of \code{"off"}
means no. In most cases, the default of \code{"on"} should not be changed,
as setting \code{clip = "off"} can cause unexpected results. It allows
drawing of data points anywhere on the plot, including in the plot margins. If
limits are set via \code{xlim} and \code{ylim} and some data points fall outside those
limits, then those data points may show up in places such as the axes, the
legend, the plot title, or the plot margins.}
  }}

\item{baseline}{Numeric value to be used as the baseline for the calculation
of the Growing Degree Days, default: \code{0}.}
}
\value{
\code{ggplot} object with the plot.
}
\description{
Plot climate variable (like \code{MAT}, \code{MTCO}, etc.), in addition to
\code{latitude} and \code{longitude}, a column with the value of \code{var}
is required.
}
